Homework B for avalg11
Peter Boström <pbos@kth.se>
2011-10-27

# Problem 1: Using the 0/1-principle for sorting network, either show that the following sorting network correctly sorts 5 inputs, or find an input where it fails. In a compare element, the larger of the two values goes in the direction of the arrow.

The sorting network will always move larger numbers down, and smaller numbers up. In no case will numbers be moved downwards if they're smaller than what they're being swapped with.

From all starting positions (x1..x4) there are enough comparators to move the largest number to the downmost position, regardless of where it starts. This will be completed before the last comparator in the middle of the sorting network. By symmetry, the smallest number will also have been placed in the upmost position.

In the final step where the lines for x1 and x4 will contain the smallest and largest number respectively, there's a comparator for the lines for x2 and x3. These two will be the numbers in the middle. After this cmoparator the largest of them will be on the line for x3, and the smaller of them on the line for x2. As x1 contains the smallest number and x4 the largest, we'll then have:

y1 ≤ y2 ≤ y3 ≤ y4

Where y are the output lines for the sorting network. Thus, the sorting network will sort all inputs (x1, x2, x3, x4).

# Problem 2: Crack RSA! Given the public RSA key (n, e) = (5192042249411, 3419183406883), find the decryption exponent d and find a number x that encrypts to your ten-digit personal number. Your answer should include x as well as explain calculations used to obtain x.

n can naively be factored into the primes p and q by testing all odd numbers up to sqrt(n), as n is not odd, and also very small. (This is the slowest step by far, but the python script easily finishes within a second.)

From p and q we can calculate the totient, and by using the extended euclidean algorithm, egcd(e, totient), we can generate e's inverse mod totient. This is the same as d, the decryption key we're looking for.

Finally we calculate c^d mod n where c, the cryptotext, is 8902240814 (my social security number) using a mod-n variant of exponentiation by squaring (to be able to calculate c^d mod n in reasonable time).

lemming@phobos:~/Code/kth/avalg11/hw2$ ./rsacrack.py 
n = 5192042249411
e = 3419183406883
p = 1532371 q = 3388241
tot(n) = 5192037328800
d = 1456182194347
c^d mod n ( c = 8902240814 d = 1456182194347 n = 5192042249411 ) = 1643423774100
m^e mod n ( m = 1643423774100 e = 3419183406883 n = 5192042249411 ) = 8902240814

Answer: 1643423774100

# Problem 3: Multiply the following polynomials using Karatsuba's algorithm.

	p(x) = x³ + 3x² + x - 1 = (x+3)x² + (x-1) = a(x)x² + b(x)
	q(x) = 2x³ - x² + 3 = (2x-1)x² + 3 = c(x)x² + d(x)

p(x) * q(x) = (a(x)x² + b(x)) * (c(x)x²) + d(x)) = a(x)c(x)x⁴ + (a(x)d(x) + b(x)c(x))x² + b(x)d(x) =
	= u(x)*x⁴ + (w(x)-u(x)-v(x))x² + v(x)

where
u(x) = a(x)*c(x) = (x+3)*(2x-1) = 2x²+5x-3
v(x) = b(x)*d(x) = (x-1)*3 = 3x-3
w(x) = (a(x)+b(x))*(c(x)+d(x)) (= a(x)*c(x) + a(x)*d(x) + b(x)*c(x) + b(x)*d(x)) =
	= ((x+3)+(x-1)) * ((2x-1)+3) = (2x+2) * (2x+2) = 4x²+8x+4

w(x) - u(x) - v(x) = 2x²+10

That is: p(x)*q(x) = (2x²+5x-3)x⁴ + (2x²+10)x² + 3x-3 = 2x⁶+5x⁵-x⁴+10x²+3x-3 

# Problem 4: Show that it is easy to find a non-trivial factor of a Carmichael number. More precisely, there is a polynomial-time algorithm for finding a non-trivial factor with probability > 1/2.


