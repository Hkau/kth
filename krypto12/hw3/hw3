Homework III, Foundations of Cryptography 2012

	Peter Boström, pbos@kth.se, 890224-0814


Attempted problems:

	1: 1+1 = 2T
	2: 1+3+2+1 = 7T

	sum: --I + --T 


1a: DH hard -> DL hard

To prove that the Diffie-Hellman assumption implies the Discrete Logarithm
assumption we're going to prove that DL being false implies that DH is false as
well. (DH->DL is equal to !DL->!DH).

DL being false means that the probability that an polynomial-time adversary A
which yields A(g,y) = log_g(y) with non-negligible probability.

Recall that a function e(N) being negligible means that e(n) < 1/n^c for every
constant c > 0 and n>n0 for some n0. Thus if Pr[A(g,y) = log_g(y)] >= 1/n^c for
some c.

To prove that !DL->!DH we're going to construct a new algorithm A' which can
solve DH with non-negligible probability using our polynomial-time adversary
A for solving DL. (A'(g^a, g^b) should yield g^ab with non-negligible
probability.)

A' (g^a, g^b):
	a = A(g, g^a) # succeeds with probability p
	b = A(g, g^b) # again, succeeds with probability p
	return g^ab

This new adversary A' makes use of A twice. Each attempt of using A succeeding
with probability p means that A' succeeds with probability p^2. Thus if
Pr[A(g,y) = log_g(y)] >= 1/n^c for some c, then Pr[A'(g^a, g^b) = g^ab] >=
(1/n^c)^2 = 1/n^2c. 2c is still only a constant, and it follows that A' is not
negligible if A is.

Thus !DL implies !DH and equivalently DH implies DL.


1b: DDH hard -> DH hard

Similar to a: DDH->DH is equivalent to !DH->!DDH. Thus we aim to prove that if
DH doesn't hold then DDH can't hold either.

If DH doesn't hold, then there's some polynomial-time adversary A for which
A(g^a, g^b) = g^ab with non-negligible probability p.

To break DDH we construct a new adversary A' which makes use of A so that
A' aims to answer A'(g^a, g^b, g^ab) with 1 and A'(g^a, g^b, g^c) with 0.

A'(g^a, g^b, X):
	g^ab = A(g^a, g^b) # succeeds with probability p
	if g^ab == X:
		return 1
	else:
		return 0

Finally, we need to show that
	Pr = |Pr[A'(g^a, g^b, g^ab) = 1] - Pr[A'(g^a, g^b, g^c)]| is not negligible.

for X=g^ab: When A succeeds (probability p), A' clearly answers 1

for X=g^c:
	No matter what A computes, X is chosen randomly, so the probability	that A'
	answers 1 is 1/2^n, as g^c will be one of the 2^n elements in the group.

Pr = |p-1/2^n| ≈ p (as 1/2^n is clearly negligible). Thus as p is not
negligible (initial assumption, A solves DH with non-negligible probability).

Thus !DH->!DDH, and equivalently DDH->DH, thus DDH->DH is proven.



2: Diffie-Hellman with special groups Gq and Hq


2a: DDH easy in Gq

Decision Diffie Hellman means distinguishing g^ab from g^c when g^a and g^b are
given and a,b,c are chosen randomly.

We can efficiently compute ψ(g, g)^ab as follows: ψ(g^a, g^b) = ψ(g, g)^ab
To compute ψ(g, g)^c, we simply do ψ(g, g^c) = ψ(g, g)^c

As ψ(g, g) is not the identity element in Hq, ψ(g, g) generates Hq. Thus
ψ(g, g)^c = ψ(g, g)^ab only holds if c = ab mod q, as they are of the same
order.

If ψ(g, g)^c = ψ(g, g)^ab, then g^c = g^ab. As both ψ(g, g)^c and ψ(g, g)^ab
are easily computable from g^a, g^b, g^c the Decision Diffie-Hellman problem in
Gq is easy.


2b: Diffie-Hellman key-exchange protocol with three parties

ψ(g, g)^abc will be the secret shared between the three parties, A, B and C.

A, B and C have secrets a, b and c respectively. Each of them compute g^a,
g^b and g^c respectively and send to the others.

Now every party raise one of the values recieved to the power of their own
secret. A could either calculate (g^b)^a = g^ab or (g^c)^a = g^ac in Gq, and
then calculate ψ(g^ab, g^c) = ψ(g, g)^abc or ψ(g^b, g^ac) = ψ(g, g)^abc.

B and C does so similarly, and all three parties get:

	ψ(g, g)^abc (in Hq)

which is their shared secret.

(A could also calculate ψ(g, g)^bc and raise it to the power a to get
ψ(g, g)^abc.)


2c: Corresponding generalization of the DDH assumption

If a, b, c, r in Zq are chosen randomly, then for every polynomial-time
algorithm A, |Pr[A(g^x, g^y, g^z, ψ(g, g)^xyz) = 1] -
Pr[A(g^x, g^y, g^z, ψ(g, g)^r) = 1]| is negligible.

(A polynomial-time adversary observing g^a, g^b, g^c, can compute ψ(g, g)^ab,
ψ(g, g)^ac and ψ(g, g)^bc but not ψ(g, g)^abc, and thus cannot separate it from
ψ(g, g)^r with a randomly-chosen r.)


2d: Man-in-the-middle attack on this scheme.

The eavesdropper E chooses three random secrets Ea, Eb and Ec. For each
participant A, B, C the eavesdropper E pose as the two others, sending to A for
instance g^Eb and g^Ec instead, claiming that they are from B and C
respectively. By posing like this, E and A establishes the shared secret
ψ(g, g)^aEbEc, E and B establishes the shared secret ψ(g, g)^bEaEc and E and C
establishes ψ(g, g)^cEaEb.

Any traffic sent from A to B for instance, is decrypted by E with ψ(g, g)^aEbEc
and again encrypted (after optionally changing the message) with ψ(g, g)^bEaEc
before relaying it to B.

This is done similarly between the other parties, decrypted by E and the
sender's shared and encrypted again with E and the reciever's shared secret.
E can of course also initiate communications with any of the participants on
her own.



3 N = pq, RSA modulus


3a ordn(a) = lcm(ordp(a), ordq(a))

Z*n is naturally (CRT) isomorphic to Z*p x Z*q, and every element in Z*n is
isomorphic to some element (x, y) in (Z*p x Z*q).

The identity element must be isomorphic to (1, 1). The order of any element
(x, y) is the smallest n for which

	(x^n mod p, y^n mod q) = (1, 1)

For x^n = 1 mod p, n must be a multiple of ordp(x), for y^n = 1 mod q, n must
be a multiple of ordq(y), the smallest n which satisfies both constraints is
per definition lcm(ordp(x), ordq(y)), so ordn((x,y)) = lcm(ordp(x), ordq(y)).

For any a in both Z*p and Z*q, a in Z*n is isomorphic to (a,a), in (Z*p x Z*q).
If we replace (x,y) and x,y in the above equation, we get:

	ordn(a) = lcm(ordp(a), ordq(a))

which is what we wanted.

3b gcd(p-1, q-1) = d

Remember that ϕ(N) = (p-1)(q-1). This gives:

	ordn(a) = ϕ(N)/d = (p-1)(q-1)/gcd(p-1,q-1) = lcm(p-1,q-1)

Which is equal to

	lcm(ordp(a), ordq(a))

if a is isomorphic to generators of Z*p and Z*q. Let's take the an a which is
isomorphic to (gp, gq) where <gp> = Z*p and <gq> = Z*q. For this specific a
the equation holds (as ordn(a) = lcm(ordp(a), ordq(a)) by 3a).


3c prove that N-a = ϕ(N)

	N - a = ϕ(N) => a = N - ϕ(N) = p*q - (p-1)(q-1) = p*q - (p*q - p - q + 1) =
		= p + q - 1

So we aim to prove that β = α^N = α^(p + q - 1) mod N

First, we need to confirm that a <= ϕ(N)/2 - 1 for p > 3 and q > 3 (or the
discrete-logarithm oracle won't even solve a):

	p + q - 1 < ϕ(N)/2 - 1
	p + q < ϕ(N)/2 = (p-1)(q-1) / 2
	2p + 2q < (p-1)(q-1) = p*q - p - q + 1
	0 < p*q - 3p - 3q + 1
	p*q - 3p - 3q + 1 > 0
	p*q + 1 > 3(p+q)

	p > 3 and q > 3 gives p,q = 5 as smallest values, 25 - 15 - 15 + 1 > 0 does
	not hold! p*q grows faster than p+q, so if we find one that holds, the rest
	will as well. 5*7 + 1 > 3(5+7) => 36 > 36, doesn't hold either, but here we
	find a breakpoint, so either (7,7) or larger, or (5,9) or larger will both
	hold. For any practical applications of RSA we can assume that p and q are
	larger than that.

So, β = α^N mod N. Is a the discrete logarithm of β? Does β = α^a mod N? Want
to show that α^N*α^-a = 1 mod N:

Remember that a = N - ϕ(N), so N - a = ϕ(n), and:

	α^N*α^-a = α^(N-a) = α^ϕ(N) mod N

From Lagrange's theorem, the order of an element α of a finite group always
divides that group, so:

	ϕ(α) | ϕ(N), or ϕ(n) = k*ϕ(α) for some integer k.

So:

	α^ϕ(N) = α^(k*ϕ(a)) = (α^ϕ(a))^k = 1^k = 1 mod N

Thus N - a = ϕ(N).


3d Factor N

Factoring N will be done by calculating ϕ(N) using the discrete logarithm
oracle in 3c.

As the oracle will give us a = N - ϕ(N), we can get ϕ(n) by calculating
ϕ(N) = N - a. (N is public and known).

So given that we have 
1: N = p*q
2: ϕ(N) = (p-1)(q-1)

If we replace q in the second equation with q = N/p:

	ϕ(N) = (p-1)(q-1) = p*q - p - q + 1 = N - p - N/p + 1
	p*ϕ(N) = p*N - p^2 - N + p
	p^2 + (ϕ(N) - N - 1)p + N = 0

Since N is public, and by using the discrete logarithm oracle in 3c we can
calculate ϕ(N), all that's left for solving p is to solve a quadratic equation
which is simple. Finally we get q by q = N/p, and we have found N's factors p
and q.



5 RSA signature scheme


5a p,q not required to be safe

For the prime-counting function π(n) (primes less than or equal to n), we have
that (according to the prime-number theorem) π approaches n/ln(n).

π(n) ~ n / ln(n)

The probability that an random number x is prime approaches 1/ln(x) for
increasing x. When we know that x is odd, the probability is twice as high.

So the probability that an odd prime p is safe approaches 2/ln((p-1)/2) (which is
the probability that (p-1)/2 is prime).

For the probability that p and q are both safe:

	2/ln((p-1)/2) * 2/ln((q-1)/2) = 4/(ln((p-1)/2) * ln((q-1)/2))

Which approaches 0 as p,q increases.


5b Prove strong RSA assumption -> standard RSA assumption

The RSA assumption states that if (taken from lecture slides):

	1: N=p*q factors into two randomly chosen primes p and q of the same
		bit-size,
	2: e is in Z*ϕ(N)
	3: m is randomly chosen in Z*N

	then for every polynomial-time algorithm A

		Pr[A(N, e, m^e mod N) = m]

	is negligible.

The strong RSA assumption states that for every polynomial-time algorithm A':

	Pr[A'(N, C) = (m, e) ^ C = m^e mod N]

	is negligible.

To prove that strong RSA implies standard RSA we're going to prove that
if standard RSA doesn't hold, then strong RSA can't hold either. We're going
to do this by constructing the new algorithm A' from an polynomial-time
algorithm A which solves the standard RSA problem with non-negligible
probability.

Algorithm A'(N, C):
	if C == 1:
		return (1, 3)

	e = choose e randomly from e >= 3
	m = A(N, e, C)
	return (m, e)

Choosing e randomly means that C corresponds to the m^e mod N of some
corresponding random (unknown) m instead, (unless C is the identity, for which
any tuple (1, e) is ok, so A' simply outputs (1, 3)). When A is able to solve
m = A(N, e, C), A' gives a new tuple (m, e) which satisfies m^e mod N. 


5c Correctness of signature scheme

	(g^(H(m)⁻¹ mod ϕ(N)/2) mod N)^H(m) mod N =
	g^((H(m)⁻¹ mod ϕ(N)/2)*H(m)) mod N

As H maps to n/3 bit numbers, and ϕ(N)/2 is at least n-2 bits, H's output will
be less than ϕ(N)/2, (for p and q to be safe primes, p,q must be at least 5 and
will be at least 3 bits each, so n will be 6 bits at least, for which n/3 < n-2
holds, and in practice N is way larger). As such H(m) = H(m) mod ϕ(N)/2 and:

	g^((H(m)⁻¹ mod ϕ(N)/2)*H(m)) mod N =
	g^((H(m)⁻¹*H(m) mod ϕ(N)/2)) mod N =
	g^(1 mod ϕ(N)/2) mod N =
	g mod N = g


5d Quadratic residues mod N

If q is a quadratic residue mod N, there exists an x such that x² = q mod N.

q^k is still a quadratic residue mod n, as x^2k = q^k mod N, and (x^k)^2 =
q^k mod N, so its primitive root is x^k mod N.


5e 

== TODO ==



6 Lamport's signature scheme

An adversary can sign any combination of 0/1 values of which it has seen the
secret key of both. For all other bits it has to choose the secret-key part
corresponding to the only bit of which it has seen the secret key to.

That is, if the signer signs {1}^k, an adversary can sign only 1-bits, as it
has not seen the secret-key value of any 0-bits. If the signer reuses her
secret key to sign {0}^k then we can recieve the secret key and sign all
values. So a chosen-plaintext attack would be simple. But the signer is however
not likely to do that at all.

So long as she signs random or hashed messages, we can expect to recieve half
of the unknown secret key pairs for each new message signed after the first
message. (For each bit for which only one part of the key pair is known,
there's a 50% probability that the next message has that bit flipped.)

In this case, we can expect to recieve the whole secret key after O(log(k)) 
messages with good probability. When we have the whole secret key we can sign
any message of length k that we want.

If we want to fake ANY message however where the message isn't hashed before
being signed, we need to recieve at most three distinct messages. The first one
will give us a set of bits which we know corresponding secret-key parts for. If
the second one only differs from the first with a single bit, then we know one
secret-key part more, but all combinations of the bits we know only form these
two first messages. If not, we can generate a third message which we can forge
a signature to (just flip one of the changed bits back). The third distinct
message must however differ in another bit, and as such we can generate a
fourth message from these three (if they differ in two bits, we have 2^2 = 4
combinations of these).

So, we can either forge a new message after three distinct unhashed messages,
or we can expect to recover the key in O(log(k)) if messages are either hashed
or chosen randomly. A chosen-plaintext attack takes 2 messages to recover the
entire key.



